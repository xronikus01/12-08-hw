# 12.8. Резервное копирование баз данных — Гаран Степан


---

---

## Задание 1. Резервное копирование

### 1.1. Восстановление данных в полном объёме за предыдущий день
Подходит **полное резервное копирование (Full backup)** один раз в сутки (например, ночью).
Тогда для восстановления “за предыдущий день” достаточно взять последний полный бэкап и развернуть его.

Чтобы уменьшить объём хранения, часто используют схему:
- периодический **полный бэкап** (например, раз в неделю),
- между ними — **дифференциальные** или **инкрементные** бэкапы.

Но если требование — именно “полный объём за предыдущий день” и важна простота восстановления, то ежедневный full backup — самый прямой вариант.


### 1.2. Восстановление данных за час до предполагаемой поломки
Подходит восстановление **на момент времени (Point-in-Time Recovery, PITR)**:
- делаем **полный бэкап** (например, раз в сутки),
- дополнительно сохраняем **журналы изменений** (WAL для PostgreSQL / binlog для MySQL),
- при аварии восстанавливаем full backup и “докатываем” журналы до нужного времени (например, до T-1 час).

Так можно получить состояние базы “за час до поломки” с точностью до минут/секунд (в зависимости от частоты и режима логирования).


### 1.3.* Мгновенное переключение на работающую/починенную БД
Да, такой кейс возможен — это называется **failover** (аварийное переключение).

Пример: есть основная БД (master/primary) и реплика (standby/replica), которая постоянно получает изменения.
При падении основной БД система (или администратор) делает **переключение**:
- реплика становится новой основной БД (promote),
- приложение/прокси перенаправляет подключения на новый primary.

Для “почти мгновенного” переключения обычно используют:
- репликацию (например, primary → standby),
- менеджер/оркестратор (Patroni/Keepalived/Orchestrator, Kubernetes и т.п.),
- виртуальный IP / DNS / балансировщик, чтобы приложению не менять адрес.

Важно: полностью “без потерь” зависит от режима репликации:
- при **синхронной** репликации потери данных минимальны/нулевые, но ниже производительность;
- при **асинхронной** переключение быстрее и проще, но возможна потеря последних транзакций.


---

## Задание 2. PostgreSQL

### 2.1. Пример команды резервирования и восстановления (pg_dump/pg_restore)
Бэкап одной базы в формате custom:

```bash
pg_dump -U postgres -h localhost -p 5432 -F c -f backup_demo.dump backup_demo

Создать пустую базу для восстановления:

createdb -U postgres -h localhost -p 5432 backup_demo_restore

Восстановить бэкап в новую базу:

pg_restore -U postgres -h localhost -p 5432 -d backup_demo_restore backup_demo.dump

Проверка, что данные на месте (пример):

psql -U postgres -h localhost -p 5432 -d backup_demo_restore -c "SELECT * FROM t;"
```
### 2.1.* Можно ли автоматизировать? Как?

Да, можно:

Windows: Task Scheduler (Планировщик задач)

Linux: cron

Скрипт (PowerShell / bash), который:

делает дамп

кладёт файл в папку с датой

удаляет старые бэкапы (например старше 7/30 дней)

Хранение бэкапов:

локально + копия в облако (S3/Google Drive/FTP)

Для прод-систем обычно добавляют:

логирование (в файл)

уведомления при ошибке (Telegram/email)

---


## Задание 3. MySQL

### 3.1. Пример команды инкрементного резервного копирования
В MySQL «инкрементный бэкап» обычно делают через **binlog** (binary log) — журнал всех изменений (INSERT/UPDATE/DELETE).
Схема такая:

1) Делаем **полный бэкап** (база на момент времени T0).  
2) Для восстановления «на момент позже» — применяем изменения из **binlog** за нужный интервал (это и есть инкремент).

Пример полного бэкапа:

```bash
mysqldump -u root -p --single-transaction --routines --events --databases mydb > full.sql
Пример «инкремента» (применяем изменения из binlog по позиции):

mysqlbinlog --start-position=861 --stop-position=1629 mysql-bin.000003 | mysql -u root -p mydb
Также можно выбирать диапазон по времени:

mysqlbinlog --start-datetime="2026-01-18 10:00:00" --stop-datetime="2026-01-18 11:00:00" mysql-bin.000003 | mysql -u root -p mydb
```
...

### 3.1.* В каких случаях использование реплики будет давать преимущество по сравнению с обычным резервным копированием?

Реплика даёт преимущество, когда важно быстрое восстановление и снижение нагрузки, например:

Минимальный простой: при сбое master можно быстро переключиться на replica (failover).

Разгрузка чтения: отчёты/аналитика/часть SELECT можно выполнять на replica, снижая нагрузку на master.

Бэкапы без нагрузки на прод: резервные копии можно делать с replica, чтобы не «тормозить» master.

Технические работы: обновления/проверки можно проводить на replica безопаснее.

Важно: реплика не заменяет бэкапы.
Если данные удалили ошибкой, попали под шифровальщик или внесли неправильные изменения — это может реплицироваться на replica. Поэтому на практике используют репликацию + регулярные бэкапы.
...

---
